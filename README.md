# NixLabs

by Vladislav Maliarenko, National Technical University "Kharkiv Polytechnic Institute", group KN-26.

<ul>
  <li>[lab 1](###lab-1)</li>  
</ul>

(###lab-1)
Tasks: <br/>
Задача 1:<br/>
Написать собственные функции для работы со строками и числами:<br/>
функция reverse(), которая параметром принимает строку, а возвращает ее в перевернутом виде,<br/>
функция ucFirst(), которая параметром принимает строку, а возвращает эту же строку, сделав ее
первую букву заглавной<br/>
функция ucWords(), которая принимает строку и делает заглавной первую букву каждого слова этой
строки.<br/>
console.log(reverse(&#39;abcde&#39;)); // =&gt; &#39;edcba&#39;<br/>
console.log(ucFirst(&#39;abcde&#39;)); // =&gt; &#39;Abcde&#39;<br/>
console.log(ucWords(&#39;abcde abcde abcde&#39;)); // =&gt; &#39;Abcde Abcde Abcde&#39;<br/>

а также функции для валидации разных сущностей<br/>
функцию isEmail параметром принимает строку и проверяет, является ли она корректным емейлом
или нет. Если является - возвращает true, если не является - то false. Упрощенный валидный email
это - больше 3х символов имя пользователя + @ + больше 3х символов домен второго уровня + . +
больше 2 символов домен верхнего уровня<br/>
функцию isUrl для проверки url<br/>
функцию isDate для проверки даты<br/>
функцию isPhoneNumber для проверки телефона (+380 98 xxxxxxx, +380 50 xxxxxxx)<br/>
console.log(isEmail(‘html@gmail.com’)); // true<br/>
console.log(isEmail(‘h@g.com’)); // false<br/>
console.log(isEmail(‘html@gmail’)); // false<br/>
console.log(isUrl(&#39;http://html.net&#39;)); // true<br/>
console.log(isUrl(&#39;html.net&#39;)); // true<br/>
console.log(isUrl(&#39;html’)); // false<br/>
console.log(isDate(&#39;12.05.2020&#39;)); // true<br/>
console.log(isDate(&#39;12-05-2020&#39;)); // true<br/>
console.log(isDate(&#39;12/05/2020&#39;)); // true<br/>
console.log(isDate(&#39;dfsdfsdf&#39;)); // false<br/>
console.log(isPhoneNumber(&#39;+380989817689&#39;)); // true<br/>
console.log(isPhoneNumber(&#39;0000989817689&#39;)); // false<br/>
* - если есть идеи как решить задачи несколькими способами - это очень приветствуется<br/>

Задача 2:<br/>
FizzBuzz<br/>

Задача 3:<br/>
3.1 Написать функцию, которая принимает два массива arr1 (любые элементы) и arr2 (только целые
числа). Функция возвращает массив элементов из arr1, индексы которых представлены, во втором
массиве.<br/>
findArray([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;], [2, 4]) // [&#39;a&#39;, &#39;a&#39;]<br/>
findArray([0, 1, 5, 2, 1, 8, 9, 1, 5], [1, 4, 7]) // [1, 1, 1]<br/>
findArray([1, 2, 3, 4, 5], [2,2,2]) // [3,3,3]<br/>
findArray([1,2,3], []) // [ ]<br/>
findArray([], [2,1,3]) // [ ]<br/>
findArray([], []) // [ ]<br/>

3.2 Написать функцию, которая принимает массив строк из одинаковых букв и возвращает новый
массив, который будет отличаться тем, что длина каждого элемента равна средней длине элементов
предыдущего массива.<br/>
[&#39;u&#39;, &#39;y&#39;] =&gt; [&#39;u&#39;, &#39;y&#39;] // average length is 1<br/>
[&#39;aa&#39;, &#39;bbb&#39;, &#39;cccc&#39;] =&gt; [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] // average length is 3<br/>
[&#39;aa&#39;, &#39;bb&#39;, &#39;ddd&#39;, &#39;eee&#39;] =&gt; [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ddd&#39;, &#39;eee&#39;] // average length is 2.5 round up to 3<br/>

Задача 4:<br/>
Есть 2 массива данных arr1 и arr2 https://jsfiddle.net/fegaxyc6/1 необходимо провести манипуляции с
данными<br/>
4.1 создать новый массив данных из объектов в массивах arr1 и arr2 в которых:<br/>
balance &gt; 2000<br/>
age &lt; 30<br/>
eyeColor - blue или brown<br/>
и которые имеют теги &#39;velit&#39; и &#39;anim&#39;<br/>
filterArrays(arr1,arr2) // [ {...}, {...}, {...} ]<br/>
4.2 оздать новый массив уникальных тегов со всех тегов из массивов arr1 и arr2 и добавить
каждому тегу уникальный id.<br/>
findUniqueTags(arr1, arr2) // [ { id: 0, name: ‘cillum’}, ……]<br/>
4.3 создать функцию, которая будет принимать любое количество массивов и будет возвращать
совершенно новый массив который будет включать полную копию всех входящих данных(все
соответствующие массивы и объекты будут иметь разные ссылки). для решения использовать
массивы arr1 и arr2.<br/>

copy(arr1, arr2) // newArr1 !== arr1 → true; newArr1.tags !== arr1.tags → true<br/>
